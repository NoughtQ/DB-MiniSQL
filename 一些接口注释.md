# 一些接口注释

## 1 DISK AND BUFFER POOL MANAGER

### DiskManager

应该不会用到，用到了再来找我（

### Page

Page 是页在内存中的存在形式。这个类里面的第一个成员就是一个 4K 数组，也就是页的内容，其他成员(比如 page_id_, pin_count_, is_dirty_)只有当这页在内存中时才会用到，也就是说并不保证 4KB 的数据中存了 page_id。

其他的 Page 类如果要存到磁盘中，都需要通过这个 Page 类，要么把数据拷贝过去，要么直接 reinterpret_cast，只要确保 page_id 相同就可以写到正确位置。

### BufferPoolManager

没写的说明理论上不应用到

```c++
Page *NewPage(page_id_t &page_id);
```

- 新建一页，返回 Page 指针，并写上新的 page_id。全局的新页应该是从 0 开始连续的，但如果有多个函数同时申请就不一定了。
- 保证新页数据全是 0

```c++
Page *FetchPage(page_id_t page_id);
```

获取一页的数据，不管他在内存还是磁盘。返回 Page 指针。

```c++
bool UnpinPage(page_id_t page_id, bool is_dirty);
```

***注意！！！！！***
***每个 NewPage 和 FetchPage 都必须配对一个 UnpinPage***

- is_dirty 只需要管当次访问有没有写。
- 理论上可以有多个 page 被 pin，但我们是单线程，如果有好多 pin 大概率有问题。
- 必然成功的，不然也有问题

```c++
bool DeletePage(page_id_t page_id);
```

表示我想释放这一页的空间，不管他在内存还是磁盘。也是必成功的。

## 2 RECORD MANAGER

### Column, Schema, Field 和 Row

- Column 相当于标明一个列的名字和属性
- Schema 是一个列的集合，也就是一个表的结构

上面这俩表示抽象的结构，下面的存具体数据

- Field 就是某行某列的一个具体值
- Row 是一行，也就是好几个 Field 的集合

处理一个表的时候，上下两部分的信息要吻合，因为代码里会检查

然后这个 Field 的实现非常抽象，他没有给获取具体数据的接口，比如如果是整数类型，你只能用 SerializeTo 序列化到一块 int 的内存里，所以我感觉应该用不到，Field 之间的比较也很特殊，如果要用再找我

### RowId

这是一行的标识符，但是其实并不代表一行的 RowId 就一直不变了，他其实对应一些物理位置信息，所以在 Update 的时候可能会变，上层需要跟踪 RowId 的变化。（具体在 TableHeap）在 B+ 树里应该不用考虑

### TableHeap

这里用来存储**纯数据**，数据**无序**。一个 TableHeap 的 Schema 是固定的。  
所有函数都应该是成功的，因为 128G 空间应该用不完

```c++
static TableHeap *Create(BufferPoolManager *buffer_pool_manager, Schema *schema, Txn *txn, LogManager *log_manager, LockManager *lock_manager);
```

用来创建 TableHeap 对象，会帮你分配好第一页。还有一个 Create 的重构是可以指定第一页的 page_id，但是我觉得用不到。

```c++
bool InsertTuple(Row &row, Txn *txn);
```

插入一行，上层需要把数据放进 row，调用成功后再从 row 获取相应的 RowId 用于管理。

```c++
bool MarkDelete(const RowId &rid, Txn *txn);
void RollbackDelete(const RowId &rid, Txn *txn);
void ApplyDelete(const RowId &rid, Txn *txn);
```

删除指定 RowId 位置的数据。设计了两个删除应该是用于事务管理，如果没有事务的话应该用 ApplyDelete 实际删除。

```c++
bool UpdateTuple(Row &row, const RowId &rid, Txn *txn);
```

更新指定 rid 位置的数据，上层需要把数据放进 row，调用成功后再从 row 获取新的 RowId 用于管理，他可能和旧的 rid **不同**。

```c++
bool GetTuple(Row &row, Txn *txn);
```

获取数据写入 row。

```c++
void FreeTableHeap();
void DeleteTable();
```

都是释放空间，不知道为什么要写两个
建议用第一个，因为 2 用的递归，可能导致 bufferpool 爆掉

```c++
TableIterator Begin(Txn *txn);
TableIterator End();
```

返回一个迭代器，用于遍历。迭代器设计为解引用后就是 Row 对象。  
同样注意数据**无序**

## Debug

另外我塞了很多 LOG 来监测异常，除了 INFO 都是有问题的，如果碰到了可以考虑改成 ASSERT，这样可以挂 gdb 让程序挂掉然后进去调试。